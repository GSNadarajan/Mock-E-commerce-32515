const fs = require('fs').promises;\nconst fsExtra = require('fs-extra');\nconst path = require('path');\nconst OrderModel = require('../../orders/models/orderModel');\n\n// Mock fs and fs-extra modules\njest.mock('fs', () => ({\n  promises: {\n    readFile: jest.fn(),\n    writeFile: jest.fn(),\n    access: jest.fn(),\n    rename: jest.fn()\n  }\n}));\n\njest.mock('fs-extra', () => ({\n  ensureDir: jest.fn()\n}));\n\njest.mock('uuid', () => ({\n  v4: jest.fn(() => 'test-uuid')\n}));\n\ndescribe('OrderModel', () => {\n  const mockOrdersData = {\n    schemaVersion: '1.0',\n    orders: [\n      {\n        id: 'order-1',\n        userId: 'user-1',\n        items: [\n          { productId: 'product-1', name: 'Product 1', price: 10, quantity: 2 }\n        ],\n        shippingAddress: { street: '123 Main St', city: 'Test City' },\n        status: 'pending',\n        createdAt: '2023-01-01T00:00:00.000Z',\n        updatedAt: '2023-01-01T00:00:00.000Z'\n      },\n      {\n        id: 'order-2',\n        userId: 'user-2',\n        items: [\n          { productId: 'product-2', name: 'Product 2', price: 20, quantity: 1 }\n        ],\n        shippingAddress: { street: '456 Oak St', city: 'Test City' },\n        status: 'shipped',\n        createdAt: '2023-01-02T00:00:00.000Z',\n        updatedAt: '2023-01-02T00:00:00.000Z'\n      }\n    ]\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Mock successful file read\n    fs.readFile.mockResolvedValue(JSON.stringify(mockOrdersData));\n    // Mock successful directory creation\n    fsExtra.ensureDir.mockResolvedValue();\n    // Mock successful file write\n    fs.writeFile.mockResolvedValue();\n    // Mock successful file rename\n    fs.rename.mockResolvedValue();\n    // Mock successful file access\n    fs.access.mockResolvedValue();\n  });\n\n  describe('initialize', () => {\n    it('should initialize orders.json if it does not exist', async () => {\n      fs.access.mockRejectedValueOnce(new Error('ENOENT'));\n      \n      await OrderModel.initialize();\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should handle invalid JSON structure', async () => {\n      fs.readFile.mockResolvedValueOnce('invalid json');\n      \n      await OrderModel.initialize();\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalled();\n    });\n\n    it('should handle missing orders array', async () => {\n      fs.readFile.mockResolvedValueOnce(JSON.stringify({ schemaVersion: '1.0' }));\n      \n      await OrderModel.initialize();\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalled();\n    });\n\n    it('should add schema version if missing', async () => {\n      fs.readFile.mockResolvedValueOnce(JSON.stringify({ orders: [] }));\n      \n      await OrderModel.initialize();\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalled();\n    });\n  });\n\n  describe('_readData', () => {\n    it('should read and parse orders data', async () => {\n      const result = await OrderModel._readData();\n      \n      expect(fs.readFile).toHaveBeenCalled();\n      expect(result).toEqual(mockOrdersData);\n    });\n\n    it('should handle file not found error', async () => {\n      fs.access.mockRejectedValueOnce(new Error('ENOENT'));\n      fs.readFile.mockRejectedValueOnce({ code: 'ENOENT' });\n      \n      const result = await OrderModel._readData();\n      \n      expect(result).toEqual({ schemaVersion: '1.0', orders: [] });\n    });\n\n    it('should handle empty file', async () => {\n      fs.readFile.mockResolvedValueOnce('');\n      \n      const result = await OrderModel._readData();\n      \n      expect(result).toEqual({ schemaVersion: '1.0', orders: [] });\n      expect(fs.writeFile).toHaveBeenCalled();\n    });\n\n    it('should handle JSON parse error', async () => {\n      fs.readFile.mockResolvedValueOnce('invalid json');\n      \n      const result = await OrderModel._readData();\n      \n      expect(result).toEqual({ schemaVersion: '1.0', orders: [] });\n      expect(fs.writeFile).toHaveBeenCalled();\n    });\n  });\n\n  describe('_writeData', () => {\n    it('should write data to file', async () => {\n      await OrderModel._writeData(mockOrdersData);\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should handle invalid data structure', async () => {\n      await OrderModel._writeData({ invalid: 'data' });\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should handle write error with fallback', async () => {\n      fs.rename.mockRejectedValueOnce(new Error('Write error'));\n      \n      await OrderModel._writeData(mockOrdersData);\n      \n      expect(fsExtra.ensureDir).toHaveBeenCalled();\n      expect(fs.writeFile).toHaveBeenCalledTimes(2); // Once for temp file, once for fallback\n    });\n  });\n\n  describe('getAllOrders', () => {\n    it('should return all orders', async () => {\n      const orders = await OrderModel.getAllOrders();\n      \n      expect(orders).toEqual(mockOrdersData.orders);\n    });\n  });\n\n  describe('getOrderById', () => {\n    it('should return order by ID', async () => {\n      const order = await OrderModel.getOrderById('order-1');\n      \n      expect(order).toEqual(mockOrdersData.orders[0]);\n    });\n\n    it('should return null for non-existent order', async () => {\n      const order = await OrderModel.getOrderById('non-existent');\n      \n      expect(order).toBeNull();\n    });\n  });\n\n  describe('getOrdersByUserId', () => {\n    it('should return orders by user ID', async () => {\n      const orders = await OrderModel.getOrdersByUserId('user-1');\n      \n      expect(orders).toEqual([mockOrdersData.orders[0]]);\n    });\n\n    it('should return empty array for non-existent user', async () => {\n      const orders = await OrderModel.getOrdersByUserId('non-existent');\n      \n      expect(orders).toEqual([]);\n    });\n  });\n\n  describe('getOrdersByStatus', () => {\n    it('should return orders by status', async () => {\n      const orders = await OrderModel.getOrdersByStatus('shipped');\n      \n      expect(orders).toEqual([mockOrdersData.orders[1]]);\n    });\n\n    it('should return empty array for non-existent status', async () => {\n      const orders = await OrderModel.getOrdersByStatus('non-existent');\n      \n      expect(orders).toEqual([]);\n    });\n  });\n\n  describe('createOrder', () => {\n    it('should create a new order', async () => {\n      const orderData = {\n        userId: 'user-3',\n        items: [{ productId: 'product-3', name: 'Product 3', price: 30, quantity: 3 }],\n        shippingAddress: { street: '789 Pine St', city: 'Test City' }\n      };\n      \n      const newOrder = await OrderModel.createOrder(orderData);\n      \n      expect(newOrder).toHaveProperty('id', 'test-uuid');\n      expect(newOrder).toHaveProperty('status', 'pending');\n      expect(newOrder).toHaveProperty('createdAt');\n      expect(newOrder).toHaveProperty('updatedAt');\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should throw error for missing user ID', async () => {\n      const orderData = {\n        items: [{ productId: 'product-3', name: 'Product 3', price: 30, quantity: 3 }],\n        shippingAddress: { street: '789 Pine St', city: 'Test City' }\n      };\n      \n      await expect(OrderModel.createOrder(orderData)).rejects.toThrow('User ID is required');\n    });\n\n    it('should throw error for missing items', async () => {\n      const orderData = {\n        userId: 'user-3',\n        shippingAddress: { street: '789 Pine St', city: 'Test City' }\n      };\n      \n      await expect(OrderModel.createOrder(orderData)).rejects.toThrow('Order must contain at least one item');\n    });\n\n    it('should throw error for empty items array', async () => {\n      const orderData = {\n        userId: 'user-3',\n        items: [],\n        shippingAddress: { street: '789 Pine St', city: 'Test City' }\n      };\n      \n      await expect(OrderModel.createOrder(orderData)).rejects.toThrow('Order must contain at least one item');\n    });\n\n    it('should throw error for missing shipping address', async () => {\n      const orderData = {\n        userId: 'user-3',\n        items: [{ productId: 'product-3', name: 'Product 3', price: 30, quantity: 3 }]\n      };\n      \n      await expect(OrderModel.createOrder(orderData)).rejects.toThrow('Shipping address is required');\n    });\n\n    it('should throw error for invalid status', async () => {\n      const orderData = {\n        userId: 'user-3',\n        items: [{ productId: 'product-3', name: 'Product 3', price: 30, quantity: 3 }],\n        shippingAddress: { street: '789 Pine St', city: 'Test City' },\n        status: 'invalid-status'\n      };\n      \n      await expect(OrderModel.createOrder(orderData)).rejects.toThrow('Invalid order status');\n    });\n  });\n\n  describe('updateOrder', () => {\n    it('should update an existing order', async () => {\n      const updateData = {\n        status: 'delivered'\n      };\n      \n      const updatedOrder = await OrderModel.updateOrder('order-1', updateData);\n      \n      expect(updatedOrder).toHaveProperty('status', 'delivered');\n      expect(updatedOrder).toHaveProperty('updatedAt');\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should return null for non-existent order', async () => {\n      const updateData = {\n        status: 'delivered'\n      };\n      \n      const updatedOrder = await OrderModel.updateOrder('non-existent', updateData);\n      \n      expect(updatedOrder).toBeNull();\n    });\n\n    it('should throw error for invalid status', async () => {\n      const updateData = {\n        status: 'invalid-status'\n      };\n      \n      await expect(OrderModel.updateOrder('order-1', updateData)).rejects.toThrow('Invalid order status');\n    });\n\n    it('should update status history when status changes', async () => {\n      const updateData = {\n        status: 'delivered'\n      };\n      \n      const updatedOrder = await OrderModel.updateOrder('order-1', updateData);\n      \n      expect(updatedOrder.statusHistory).toBeDefined();\n      expect(updatedOrder.statusHistory[updatedOrder.statusHistory.length - 1].status).toBe('delivered');\n    });\n\n    it('should recalculate total amount when items are updated', async () => {\n      const updateData = {\n        items: [\n          { productId: 'product-1', name: 'Product 1', price: 10, quantity: 3 },\n          { productId: 'product-2', name: 'Product 2', price: 20, quantity: 1 }\n        ]\n      };\n      \n      const updatedOrder = await OrderModel.updateOrder('order-1', updateData);\n      \n      expect(updatedOrder.totalAmount).toBe(50); // (10*3 + 20*1)\n    });\n  });\n\n  describe('updateOrderStatus', () => {\n    it('should update order status', async () => {\n      const updatedOrder = await OrderModel.updateOrderStatus('order-1', 'delivered');\n      \n      expect(updatedOrder).toHaveProperty('status', 'delivered');\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should throw error for invalid status', async () => {\n      await expect(OrderModel.updateOrderStatus('order-1', 'invalid-status')).rejects.toThrow('Invalid order status');\n    });\n\n    it('should include note in status history', async () => {\n      const updatedOrder = await OrderModel.updateOrderStatus('order-1', 'delivered', 'Customer received package');\n      \n      expect(updatedOrder.statusHistory).toBeDefined();\n      const lastStatus = updatedOrder.statusHistory[updatedOrder.statusHistory.length - 1];\n      expect(lastStatus.status).toBe('delivered');\n      expect(lastStatus.note).toBe('Customer received package');\n    });\n  });\n\n  describe('deleteOrder', () => {\n    it('should delete an existing order', async () => {\n      const result = await OrderModel.deleteOrder('order-1');\n      \n      expect(result).toBe(true);\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(fs.rename).toHaveBeenCalled();\n    });\n\n    it('should return false for non-existent order', async () => {\n      const result = await OrderModel.deleteOrder('non-existent');\n      \n      expect(result).toBe(false);\n    });\n  });\n\n  describe('searchOrders', () => {\n    it('should search orders by user ID', async () => {\n      const orders = await OrderModel.searchOrders({ userId: 'user-1' });\n      \n      expect(orders).toEqual([mockOrdersData.orders[0]]);\n    });\n\n    it('should search orders by status', async () => {\n      const orders = await OrderModel.searchOrders({ status: 'shipped' });\n      \n      expect(orders).toEqual([mockOrdersData.orders[1]]);\n    });\n\n    it('should search orders by date range', async () => {\n      const orders = await OrderModel.searchOrders({\n        startDate: '2023-01-02T00:00:00.000Z',\n        endDate: '2023-01-03T00:00:00.000Z'\n      });\n      \n      expect(orders).toEqual([mockOrdersData.orders[1]]);\n    });\n\n    it('should search orders by product ID', async () => {\n      const orders = await OrderModel.searchOrders({ productId: 'product-1' });\n      \n      expect(orders).toEqual([mockOrdersData.orders[0]]);\n    });\n\n    it('should return empty array for no matches', async () => {\n      const orders = await OrderModel.searchOrders({ userId: 'non-existent' });\n      \n      expect(orders).toEqual([]);\n    });\n  });\n\n  describe('countOrdersByStatus', () => {\n    it('should count orders by status', async () => {\n      const counts = await OrderModel.countOrdersByStatus();\n      \n      expect(counts).toEqual({\n        pending: 1,\n        processing: 0,\n        shipped: 1,\n        delivered: 0,\n        cancelled: 0\n      });\n    });\n  });\n\n  describe('getUserOrderHistory', () => {\n    it('should get user order history sorted by date', async () => {\n      // Add another order for the same user with a more recent date\n      mockOrdersData.orders.push({\n        id: 'order-3',\n        userId: 'user-1',\n        items: [{ productId: 'product-3', name: 'Product 3', price: 30, quantity: 1 }],\n        shippingAddress: { street: '123 Main St', city: 'Test City' },\n        status: 'pending',\n        createdAt: '2023-01-03T00:00:00.000Z',\n        updatedAt: '2023-01-03T00:00:00.000Z'\n      });\n      \n      const orders = await OrderModel.getUserOrderHistory('user-1');\n      \n      expect(orders.length).toBe(2);\n      expect(orders[0].id).toBe('order-3'); // Most recent first\n      expect(orders[1].id).toBe('order-1');\n    });\n\n    it('should return empty array for user with no orders', async () => {\n      const orders = await OrderModel.getUserOrderHistory('non-existent');\n      \n      expect(orders).toEqual([]);\n    });\n  });\n\n  describe('getRecentOrders', () => {\n    it('should get recent orders with default limit', async () => {\n      // Add more orders to test limit\n      for (let i = 3; i <= 15; i++) {\n        mockOrdersData.orders.push({\n          id: `order-${i}`,\n          userId: `user-${i % 3 + 1}`,\n          items: [{ productId: `product-${i}`, name: `Product ${i}`, price: 10 * i, quantity: 1 }],\n          shippingAddress: { street: '123 Main St', city: 'Test City' },\n          status: 'pending',\n          createdAt: `2023-01-${i < 10 ? '0' + i : i}T00:00:00.000Z`,\n          updatedAt: `2023-01-${i < 10 ? '0' + i : i}T00:00:00.000Z`\n        });\n      }\n      \n      const orders = await OrderModel.getRecentOrders();\n      \n      expect(orders.length).toBe(10); // Default limit\n      expect(orders[0].id).toBe('order-15'); // Most recent first\n      expect(orders[9].id).toBe('order-6');\n    });\n\n    it('should respect custom limit', async () => {\n      const orders = await OrderModel.getRecentOrders(5);\n      \n      expect(orders.length).toBe(5);\n      expect(orders[0].id).toBe('order-15'); // Most recent first\n      expect(orders[4].id).toBe('order-11');\n    });\n  });\n});